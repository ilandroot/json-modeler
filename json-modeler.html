<!DOCTYPE html>
<!-- json-modeler v1.0.0 -->
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>JSON Data Modeler</title>
  <style>
html, body {
  margin: 0;
  padding: 0;
  overflow: hidden; /* â† ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ãƒãƒ¼ã‚’éè¡¨ç¤ºã«ã™ã‚‹ */
  height: 100%;
}

#cy {
  width: 100%;
  height: 100vh; /* â† ãƒ“ãƒ¥ãƒ¼ãƒãƒ¼ãƒˆå…¨ä½“ã«åºƒã’ã‚‹ */
  display: block;
}

#fieldEditor label {
  display: grid;
  grid-template-columns: 80px 1fr;
  align-items: center;
  margin-bottom: 8px;
}

#nodeDialog label {
  display: grid;
  grid-template-columns: 80px 1fr;
  gap: 6px;
  align-items: center;
  margin-bottom: 8px;
}



.generic-row {
  background-color: #eef;
}
.non-generic-row {
  background-color: #fff;
}

#attrList {
  max-height: 300px; /* å¿…è¦ã«å¿œã˜ã¦é«˜ã•èª¿æ•´ */
  overflow-y: auto;
  border-top: 1px solid #ccc;
  padding-top: 8px;
}

#currentNodeInfo {
  line-height: 1.4;
  word-break: break-all;
}

#attrType {
  width: 120px;
  margin-left: 6px;
  padding: 4px;
}

#modalOverlay {
  display: none;
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0,0,0,0.3);
  z-index: 9999;
  pointer-events: auto;
}

#typeModal {
  display: none;
  position: fixed;
  top: 30%;
  left: 50%;
  transform: translateX(-50%);
  background: #fff;
  border: 1px solid #ccc;
  padding: 10px;
  z-index: 10000;
  box-shadow: 0 4px 12px rgba(0,0,0,0.2);
}

#typeOptions {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
}

#projectionFieldsList {
  max-height: 100px;
  overflow-y: auto;
}

.menuBar {
  display: flex;
  gap: 12px;
  padding: 6px;
  background-color: #f0f0f0;
  border-bottom: 1px solid #ccc;
  position: relative;
  z-index: 2000; /* ãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã‚ˆã‚Šå‰ã«å‡ºã™ */
}

.menuGroup {
  position: relative;
}

.menuButton {
  background: #fff;
  border: 1px solid #ccc;
  padding: 4px 8px;
  cursor: pointer;
}

.menuDropdown {
  position: absolute;
  top: 100%;
  left: 0;
  background: #fff;
  border: 1px solid #ccc;
  box-shadow: 0 2px 6px rgba(0,0,0,0.2);
  display: flex;
  flex-direction: column;
  z-index: 1000;
  min-width: 120px;
  max-width: 160px;
}

.menuDropdown button {
  padding: 6px 12px;
  border: none;
  background: none;
  text-align: left;
  cursor: pointer;
}

.menuDropdown button:hover {
  background-color: #eef;
}

option.generic {
  background-color: #88c;
  color: #fff;
}
option.non-generic {
  background-color: #eee;
  color: #000;
}

/* åˆæœŸçŠ¶æ…‹ã¯éè¡¨ç¤º */
.dialog {
  display: none; 
  position: fixed;
  top: 20%;
  left: 20%;
  width: 60%;
  height: auto;
  background: #fff;
  border: 1px solid #ccc;
  padding: 1em;
  box-shadow: 0 0 10px rgba(0,0,0,0.3);
}

/* JSON è¡¨ç¤ºé–¢ä¿‚ ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ */

#previewDialog {
  position: fixed;
  top: 60px;
  left: 20px;
  width: 500px;        /* â† ã“ã‚Œã ã‘ã§åŠ‡çš„ã«æ‰±ã„ã‚„ã™ããªã‚‹ */
  max-height: 70vh;
  overflow: auto;
  background: #f4f4f4; /* ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã¯ç™½ã®ã¾ã¾ã§æ­£è§£ */
  border: 1px solid #ccc;
  padding: 10px;
  box-shadow: 0 0 10px rgba(0,0,0,0.3);
}

#previewContent {
  max-height: 60vh;
  overflow: auto;
}

#previewNodeName {
  font-weight: bold;
  margin-bottom: 8px;
}

#previewContent {
  max-height: 60vh;   /* JSON éƒ¨åˆ†ã ã‘ã«é«˜ã•åˆ¶é™ */
  overflow: auto;     /* JSON éƒ¨åˆ†ã«ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ãƒãƒ¼ã‚’å‡ºã™ */
  background: #fff;
  padding: 8px;
  border: 1px solid #ccc;
  white-space: pre;   /* æ”¹è¡Œä¿æŒã€æ¨ªã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«è¨±å¯ */
}

#previewTabs {
  display: flex;
  gap: 4px;
  margin-bottom: 8px;
}

#previewTabs button {
  padding: 6px 12px;
  border: 1px solid #ccc;
  background: #eee;
  cursor: pointer;
  border-radius: 4px 4px 0 0;
}

#previewTabs button.active {
  background: white;
  border-bottom: 1px solid white;
  font-weight: bold;
}

/* ãƒãƒ¼ãƒ‰ç·¨é›†ãƒ€ã‚¤ã‚¢ãƒ­ã‚° */
#fieldEditor {
  position: fixed;
  right: 20px;
  top: 60px; /* ãƒ¡ãƒ‹ãƒ¥ãƒ¼ãƒãƒ¼ã®ä¸‹ã«æƒãˆã‚‹ */
  background: #f4f4f4;
  border: 1px solid #ccc;
  padding: 10px;
  max-height: 90vh;
  overflow: auto;
  display: none;
}

/* ã‚¨ãƒƒã‚¸ç·¨é›†ãƒ€ã‚¤ã‚¢ãƒ­ã‚° */
#edgeEditPanel {
  position: fixed;
  right: 20px;
  top: 60px; /* ãƒ¡ãƒ‹ãƒ¥ãƒ¼ãƒãƒ¼ç›´ä¸‹ã«æƒãˆã‚‹ */
  background: #f4f4f4;
  border: 1px solid #ccc;
  padding: 10px;
  display: none;
  width: 360px; /* å¿…è¦ã«å¿œã˜ã¦èª¿æ•´ */
  z-index: 1000; /* ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‚ˆã‚Šå¾Œã‚ã€è¿½åŠ ãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã‚ˆã‚Šä¸Š */
}

/* ãƒãƒ¼ãƒ‰è¿½åŠ ãƒ€ã‚¤ã‚¢ãƒ­ã‚° */
#nodeDialog {
  position: fixed;
  left: 20px;
  top: 60px; /* ãƒ¡ãƒ‹ãƒ¥ãƒ¼ãƒãƒ¼ã®ä¸‹ã«æƒãˆã‚‹ */
  background: #f4f4f4;
  border: 1px solid #ccc;
  padding: 10px;
  display: none;
  width: 300px; /* å¿…è¦ã«å¿œã˜ã¦èª¿æ•´ */
}

/* ã‚¨ãƒƒã‚¸è¿½åŠ ãƒ€ã‚¤ã‚¢ãƒ­ã‚° */
#edgeDialog {
  position: fixed;
  left: 20px;
  top: 60px; /* ãƒãƒ¼ãƒ‰è¿½åŠ ã¨åŒã˜ä½ç½®ã«æƒãˆã‚‹ */
  background: #f4f4f4;
  border: 1px solid #ccc;
  padding: 10px;
  display: none;
  width: 300px; /* å¿…è¦ãªã‚‰èª¿æ•´ */
  z-index: 1000; /* ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‚ˆã‚Šå¾Œã‚ã€ç·¨é›†ãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã‚ˆã‚Šä¸‹ */
}

/* ãƒãƒ¼ãƒ‰å®Ÿè£…åä¸€è¦§è¨­å®šãƒ€ã‚¤ã‚¢ãƒ­ã‚° */
#implEditor {
  position: fixed;
  right: 20px;
  top: 60px; /* ãƒ¡ãƒ‹ãƒ¥ãƒ¼ãƒãƒ¼ç›´ä¸‹ã«æƒãˆã‚‹ */
  background: #f4f4f4;
  border: 1px solid #ccc;
  padding: 15px;
  display: none;
  width: 360px; /* å¿…è¦ãªã‚‰èª¿æ•´ */
  z-index: 1000; /* ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‚ˆã‚Šå¾Œã‚ã€ä»–ã®ç·¨é›†ãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã¨åŒã˜å±¤ */
}

#implEditor table {
  display: block;
  max-height: 400px;
  overflow-y: auto;
}

.toast {
  position: fixed;
  top: 60px;
  left: 20px;
  background: #333;
  color: #fff;
  padding: 8px 14px;
  border-radius: 4px;
  opacity: 0;
  transition: opacity 0.4s;
  pointer-events: none;
  font-size: 14px;
}

.toast.show {
  opacity: 1;
}

  </style>
  <!-- CDNãƒ©ã‚¤ãƒ–ãƒ©ãƒªèª­ã¿è¾¼ã¿ -->
  <script src="https://unpkg.com/cytoscape@3.27.0/dist/cytoscape.min.js"></script>
  <script src="https://unpkg.com/dagre@0.8.5/dist/dagre.min.js"></script>
  <script src="https://unpkg.com/cytoscape-dagre@2.5.0/cytoscape-dagre.js"></script>
  <script>
    cytoscape.use(window.cytoscapeDagre);
  </script>
</head>
<body>
  <!-- ãƒˆãƒƒãƒ—ãƒ¡ãƒ‹ãƒ¥ãƒ¼ ã“ã“ã‹ã‚‰ -->
  <div class="menuBar">
    <!-- ãƒ•ã‚¡ã‚¤ãƒ« ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‚°ãƒ«ãƒ¼ãƒ—ã‚‚è¿½åŠ å¯èƒ½ -->
    <div class="menuGroup">
      <button class="menuButton" onclick="toggleMenu('fileMenu')">ãƒ•ã‚¡ã‚¤ãƒ« â–¾</button>
      <div id="fileMenu" class="menuDropdown" style="display:none;">
        <button onclick="newModel(); closeAllMenus()">æ–°è¦ä½œæˆ</button>
        <button id="importModelBtn">ã‚¹ã‚¯ãƒªãƒ—ãƒˆ...</button>
        <button id="load">èª­è¾¼ã¿...</button>
        <button id="save">ä¿å­˜...</button>
      </div>
    </div>
    <!-- ç·¨é›† ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‚°ãƒ«ãƒ¼ãƒ—ã‚‚è¿½åŠ å¯èƒ½ -->
    <div class="menuGroup">
      <button class="menuButton" onclick="toggleMenu('editMenu')">ç·¨é›† â–¾</button>
      <div id="editMenu" class="menuDropdown" style="display:none;">
        <button onclick="openNodeDialog(); closeAllMenus()">ãƒãƒ¼ãƒ‰è¿½åŠ </button>
        <button onclick="openEdgeDialog(); closeAllMenus()">ã‚¨ãƒƒã‚¸è¿½åŠ </button>
        <button onclick="deleteSelected(); closeAllMenus()">é¸æŠã‚’å‰Šé™¤</button>
        <button onclick="clearSelection(); closeAllMenus()">é¸æŠè§£é™¤</button>
        <button onclick="openImplEditor(); closeAllMenus()">ãƒãƒ¼ãƒ‰å®Ÿè£…å</button>
      </div>
    </div>
    <!-- è¡¨ç¤º ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‚°ãƒ«ãƒ¼ãƒ— -->
    <div class="menuGroup">
      <button class="menuButton" onclick="toggleMenu('viewMenu')">è¡¨ç¤º â–¾</button>
      <div id="viewMenu" class="menuDropdown" style="display:none;">
        <button onclick="showAllNodes(); closeAllMenus()">å…¨ãƒãƒ¼ãƒ‰è¡¨ç¤º</button>
        <button onclick="showOnlyNonGeneric(); closeAllMenus()">é€šå¸¸ãƒãƒ¼ãƒ‰è¡¨ç¤º</button>
        <button onclick="showOnlyGeneric(); closeAllMenus()">å‹ãƒãƒ¼ãƒ‰è¡¨ç¤º</button>
        <button onclick="fitAll(); closeAllMenus()">å…¨ä½“è¡¨ç¤º</button>
      </div>
    </div>

    <div class="menuItem">
      <button class="menuButton" onclick="checkGraph()">ãƒã‚§ãƒƒã‚¯</button>
    </div>

    <div class="menuItem">
      <button class="menuButton" onclick="previewJson()">ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼</button>
    </div>

    <div class="menuItem">
      <label for="modelNameInput">ãƒ¢ãƒ‡ãƒ«å:</label>
      <input id="modelNameInput" type="text" placeholder="ãƒ¢ãƒ‡ãƒ«åã‚’å…¥åŠ›">
    </div>
    <div class="menuItem">
      <label for="nodeLabelModeSelect">ãƒ©ãƒ™ãƒ«è¡¨ç¤º ãƒãƒ¼ãƒ‰:</label>
      <select id="nodeLabelModeSelect" onchange="updateNodeLabels(this.value)">
        <option value="default">default</option>
        <option value="impl_name">å®Ÿè£…å</option>
      </select>
    </div>

    <div class="menuItem">
      <label for="labelModeSelect">ã‚¨ãƒƒã‚¸:</label>
      <select id="labelModeSelect" onchange="updateEdgeLabels(this.value)">
        <option value="default">default</option>
        <option value="type">type</option>
        <option value="impl_name">å®Ÿè£…å</option>
      </select>
    </div>

  </div>

  <input type="file" id="modelFileInput" style="display:none" accept=".txt" />
  <input type="file" id="fileInput" accept=".json" style="display:none;">
  <input type="file" id="saveJaonSchema" style="display:none" />

  <!-- ãƒˆãƒƒãƒ—ãƒ¡ãƒ‹ãƒ¥ãƒ¼ ã“ã“ã¾ã§ -->

  <div id="cy"></div>

  <!--ãƒ¢ãƒ‡ãƒ«ãƒ‡ãƒ¼ã‚¿ã‚¤ãƒ³ãƒãƒ¼ãƒˆã‚¨ãƒ©ãƒ¼è¡¨ç¤ºç”¨ -->
<div id="importErrorContainer" style="
  display:none;
  position:fixed;
  top:80px;
  left:20px;
  z-index:1000;
  border:1px solid #f00;
  padding:10px;
  background:#fee;
  max-width:400px;
  font-size:14px;
">
  <h3>ã‚¤ãƒ³ãƒãƒ¼ãƒˆã‚¨ãƒ©ãƒ¼</h3>
  <ul id="importErrorList"></ul>
</div>

  <!-- ãƒãƒ¼ãƒ‰å±æ€§ç·¨é›†ç”¨ -->
  <div id="fieldEditor" >
  <h3>å±æ€§è¿½åŠ </h3>
  <div id="currentNodeInfo" style="margin-bottom:10px; font-size:14px; color:#333;">
  <div>ãƒãƒ¼ãƒ‰å: <strong id="nodeLabelText"></strong></div>
  <div>å®Ÿè£…å: <strong id="nodeImplText"></strong></div>
  <div>æ±ç”¨å‹: <strong id="nodeGenericText"></strong></div>
  </div>
  <label>å®Ÿè£…å <input id="attrName" type="text"></label><br>
  <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:6px;">
    <label for="attrType" style="flex-shrink:0;">å‹</label>
    <div style="display:flex; gap:4px;">
      <input id="attrType" type="text" placeholder="å‹ã‚’å…¥åŠ›" style="width:120px;" />
      <button type="button" onclick="openTypeSelector('attrType')" style="padding:2px 6px;">...</button>
    </div>
  </div>

  <label>è«–ç†å <input id="attrDesc" type="text"></label><br>
  <label><input id="attrRequired" type="checkbox"> å¿…é ˆ</label><br>
  <label><input id="attrDiscriminator" type="checkbox"> discriminator</label><br>
  <label><input id="attrIdentifier" type="checkbox"> identifier</label><br>
  <button id="addAttr">è¿½åŠ </button>
  <button id="closeEditor">âœ– é–‰ã˜ã‚‹</button>
  <div id="attrList"></div>
  </div>

  <!-- ãƒãƒ¼ãƒ‰è¿½åŠ  -->
  <div id="nodeDialog">
  <h3>ãƒãƒ¼ãƒ‰è¿½åŠ </h3>
  <label> åå‰ <input id="nodeName" type="text"></label><br>
  <label>
  <input type="checkbox" id="isGenericType">
  æ±ç”¨å‹ã¨ã—ã¦å®šç¾©ã™ã‚‹ï¼ˆisGenericTypeï¼‰
  </label><br>
  <button onclick="createNode()">ä½œæˆ</button>
  <button onclick="closeNodeDialog()">é–‰ã˜ã‚‹</button>
  </div>

  <!-- ã‚¨ãƒƒã‚¸è¿½åŠ  -->
  <div id="edgeDialog">
    <h3>ã‚¨ãƒƒã‚¸è¿½åŠ </h3>

    <label>Source:
      <select id="edgeSource"></select>
    </label><br>

    <label>Target:
      <select id="edgeTarget"></select>
    </label><br>

    <label>Type:
      <select id="edgeType">
        <option value="include">include</option>
        <option value="ref">ref</option>
        <option value="subtype">subtype</option>
      </select>
    </label><br>

    <label>Cardinality:
      <select id="edgeCardinality">
        <option value="1:1">1:1</option>
        <option value="1:N">1:N</option>
      </select>
    </label><br>

    <label>é–¢ä¿‚ã®è«–ç†å (rel_name):
      <input type="text" id="edgeRelName" placeholder="é–¢ä¿‚ã®è«–ç†åã‚’å…¥åŠ›" style="width: 80%;">
    </label><br>

    <button onclick="createEdge()">ä½œæˆ</button>
    <button onclick="closeEdgeDialog()">é–‰ã˜ã‚‹</button>
  </div>
  
  <!-- å®Ÿè£…åä¸€è¦§è¨­å®šï¼ˆãƒãƒ¼ãƒ‰ï¼‰ -->
  <div id="implEditor">
    <h3>ãƒãƒ¼ãƒ‰ä¸€è¦§ å®Ÿè£…åç·¨é›†</h3>
    <input type="text" placeholder="è«–ç†åã§æ¤œç´¢â€¦" oninput="filterNodes(this.value)">
    <table id="implTable" border="1" cellpadding="4">
      <tr><th>è«–ç†åï¼ˆlabelï¼‰</th><th>å®Ÿè£…åï¼ˆimpl_nameï¼‰</th><th>ææ¡ˆ</th></tr>
    </table>
    <button onclick="saveImplNames()">ä¿å­˜</button>
    <button onclick="closeImplEditor()">é–‰ã˜ã‚‹</button>
  </div>
  
  <!-- ã‚¨ãƒƒã‚¸åã€å®Ÿè£…åè¨­å®š-->
  <div id="edgeEditPanel" >
    <h3>ã‚¨ãƒƒã‚¸ç·¨é›†</h3>
    <!-- è¡¨ç¤ºå°‚ç”¨: Source / Target / Type -->
    <p>æ¥ç¶šå…ƒ: <span id="edgeSourceName"></span></p>
    <p>æ¥ç¶šå…ˆ: <span id="edgeTargetName"></span></p>
    <p>ã‚¿ã‚¤ãƒ—: <span id="edgeTypeName"></span></p>

    <!-- include â†’ ref å¤‰æ›æ©Ÿèƒ½ -->
    <div id="conversionSection" style="display: none;">
      <hr>
      <label>é–¢ä¿‚å¤‰æ›:</label><br>
      <button onclick="convertIncludeToRef()">ref ã«å¤‰æ›ã™ã‚‹</button>
      <button onclick="convertRefToInclude()">include ã«å¤‰æ›ã™ã‚‹</button><br><br>

      <div id="conversionNotice" style="color: #3366cc; font-size: 0.9em;"></div>
    </div>
    <hr>
    <p>
    é–¢ä¿‚ã®è«–ç†å: <input type="text" id="edgeRelNameInput" placeholder="é–¢ä¿‚ã®è«–ç†åã‚’å…¥åŠ›" style="width: 80%;">
    </p>
    <label>è¡¨ç¤ºåï¼ˆlabelï¼‰:</label><br>
    <input type="text" id="edgeLabelInput"><br><br>
    <label>ãƒ‡ãƒ¼ã‚¿å‹ï¼ˆimpl_typeï¼‰:</label><br>
    <div style="display:flex; gap:4px; align-items:center; margin-bottom:8px;">
      <input type="text" id="edgeImplTypeInput" style="width:120px;" />
      <button type="button" id="edgeImplTypeSelect" onclick="openTypeSelector('edgeImplTypeInput',true)" style="padding:2px 6px;">...</button>
    </div>

    <label id="edgeImplLabel">å®Ÿè£…åï¼ˆimpl_nameï¼‰:</label>
    <input type="text" id="edgeImplInput"><br>

    <div id="projectionFieldsSection" style="margin-top:12px; display:none;">
      <label>å‚ç…§å±æ€§è¨­å®šï¼ˆprojection_fieldsï¼‰:</label><br>
      <div id="projectionFieldsList" style="margin-left:8px;">
        <!-- å‹•çš„ã«å‚ç…§å…ˆãƒãƒ¼ãƒ‰å±æ€§ä¸€è¦§ã‚’è¿½åŠ  -->
      </div>
    </div>

    <label><input type="checkbox" id="edgeRequiredCheckbox" /> å¿…é ˆ (required)</label><br>
    <hr>
    <button onclick="saveEdgeProperties()">ä¿å­˜</button>
    <button id="closeEdgeEdit" onclick="closeEdgeEdit()">é–‰ã˜ã‚‹</button>
  </div>

  <!-- ãƒ€ã‚¤ã‚¢ãƒ­ã‚°è¿½åŠ ï¼ˆãƒãƒ¼ãƒ‰ãŠã‚ˆã³ã‚¨ãƒƒã‚¸ã€‚ãƒ‡ãƒ¼ã‚¿å‹é¸æŠç”¨ï¼‰-->
  <div id="modalOverlay"></div>

  <div id="typeModal">
  <h4>å‹ã‚’é¸æŠã—ã¦ãã ã•ã„</h4>
  <div id="typeOptions"></div>
  <br>
  <button onclick="closeTypeModal()">é–‰ã˜ã‚‹</button>
  </div>

  <!-- ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ãƒ€ã‚¤ã‚¢ãƒ­ã‚° -->
  <div id="previewDialog" class="dialog">
  <div id="previewNodeName"></div>
  <!-- â–¼ è¿½åŠ ï¼šã‚¿ãƒ– -->
  <div id="previewTabs" style="margin-bottom: 8px;">
    <button id="tabJson" onclick="setPreviewMode('json')">JSON</button>
    <button id="tabJs" onclick="setPreviewMode('js')">JS Object</button>
    <button id="tabJsShorthand" onclick="setPreviewMode('js-shorthand')">JS Object (Shorthand)</button>
    <button id="tabJsVars" onclick="setPreviewMode('js-vars')">JS Variables</button>
  </div>

  <!-- â–² ã“ã“ã¾ã§ -->
  <pre id="previewContent"></pre>
  <button onclick="closePreviewDialog()">é–‰ã˜ã‚‹</button>
  <button onclick="copyPreviewJson()">ã‚³ãƒ”ãƒ¼</button>
  </div>

  <!-- ãƒˆãƒ¼ã‚¹ãƒˆè¡¨ç¤ºç”¨ -->
  <div id="toast" class="toast">ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸ</div>

<script>

function toggleMenu(menuId) {
  const menu = document.getElementById(menuId);
  const isVisible = menu.style.display === "block";
  document.querySelectorAll(".menuDropdown").forEach(m => m.style.display = "none");
  if (!isVisible) menu.style.display = "block";
}

function closeAllMenus() {
  document.querySelectorAll(".menuDropdown").forEach(menu => {
    menu.style.display = "none";
  });
}

let currentModelName = "ãƒ¢ãƒ‡ãƒ«å"; // åˆæœŸå€¤ï¼ˆç©ºã§ã‚‚OKï¼‰

function newModel(){
  const confirmed = window.confirm("ç¾åœ¨ã®ãƒ¢ãƒ‡ãƒ«ã‚’ç ´æ£„ã—ã¾ã™ã‹ï¼Ÿ");
  if (confirmed) {
    location.reload(); // ãƒšãƒ¼ã‚¸ã‚’ãƒªãƒ­ãƒ¼ãƒ‰ã—ã¦åˆæœŸçŠ¶æ…‹ã«æˆ»ã™
  }
  closeAllDialogs();
}

document.getElementById('importModelBtn').addEventListener('click', () => {
  document.getElementById('modelFileInput').click();
  closeAllMenus();
});

// ç”»é¢ã®ã©ã“ã‹ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ãŸã‚‰ãƒ¡ãƒ‹ãƒ¥ãƒ¼ãŒé–‰ã˜ã‚‹ã€
document.addEventListener("click", (e) => {
  if (!e.target.closest(".menuBar")) {
    closeAllMenus();
  }
});

// Graphã‚¹ã‚¯ãƒªãƒ—ãƒˆãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿å‡¦ç†
document.getElementById('modelFileInput').addEventListener('change', (event) => {
  const file = event.target.files[0];
  if (!file) return;

  // ğŸ”½ ãƒ•ã‚¡ã‚¤ãƒ«åã‹ã‚‰ãƒ¢ãƒ‡ãƒ«åã‚’æŠ½å‡ºã—ã¦åæ˜ 
  const baseName = file.name.replace(/\.[^/.]+$/, ""); // æ‹¡å¼µå­é™¤å» â†’ "graph-script-sudoku"
  const modelName = baseName.replace(/^graph-script-/, ""); // ãƒ—ãƒ¬ãƒ•ã‚£ãƒƒã‚¯ã‚¹é™¤å» â†’ "sudoku"
  const modelNameInput = document.getElementById("modelNameInput");
  if (modelNameInput) {
    modelNameInput.value = modelName;
  }

  const reader = new FileReader();
  reader.onload = function(e) {
    const text = e.target.result;
    const errors = parseModelText(text);
    
    if (errors.length > 0) {
      showImportErrors(errors); // GUIã«è¡¨ç¤º
      return;
    }

    const { nodes, edges } = parseModelTxtWithStyle(text);
    if (cy_model) {
      cy_model.off('tap');
      cy_model.off('click');
      cy_model.off('mouseover');
      cy_model.destroy();
      cy_model = null;
    }

    cy_model = cytoscape({
      container: document.getElementById('cy'),
      elements: [...nodes, ...edges],
      style: model_st,
      layout: { name: 'dagre' },
      wheelSensitivity: 0.2
    });

    // ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°
    bindNodeEvents(cy_model);
    bindEdgeEvents(cy_model);
    setupClickPositionTracking();
    cy_model.elements().unselect();

    // ç¾åœ¨ã®ãƒ©ãƒ™ãƒ«è¡¨ç¤ºãƒ¢ãƒ¼ãƒ‰ã§ä¸€æ‹¬è¨­å®š
    graphLabelUpdate();
    graphNodeLabelUpdate();

  };
  reader.readAsText(file);
  
  // ğŸ” åŒã˜ãƒ•ã‚¡ã‚¤ãƒ«ã§ã‚‚å†é¸æŠã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹
  event.target.value = '';

  // ãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã‚’éè¡¨ç¤ºã«ã™ã‚‹
  closeAllDialogs();

});

// è¡¨ç¤ºãƒ­ã‚¸ãƒƒã‚¯ ã“ã“ã‹ã‚‰
function showAllNodes() {
  cy_model.nodes().forEach(n => n.style('display', 'element'));
}

function showOnlyNonGeneric() {
  cy_model.nodes().forEach(n => {
    const isGeneric = n.data('isGenericType') === true;
    n.style('display', isGeneric ? 'none' : 'element');
  });
}

function showOnlyGeneric() {
  cy_model.nodes().forEach(n => {
    const isGeneric = n.data('isGenericType') === true;
    n.style('display', isGeneric ? 'element' : 'none');
  });
}

function fitAll() {
  cy_model.fit(cy_model.nodes(':visible'), 50); // ä½™ç™½50px
}
// è¡¨ç¤ºãƒ­ã‚¸ãƒƒã‚¯ ã“ã“ã¾ã§

function parseModelTxtWithStyle(text) {
  const lines = text.split('\n').map(l => l.trim()).filter(l => l);
  const nodes = new Set();
  const edges = [];

  lines.forEach(line => {
    if (line.startsWith('#') || line.startsWith('//') || line === '') return;

    // é–¢ä¿‚å¼ã®ãƒ‘ã‚¿ãƒ¼ãƒ³
    const relationMatch = line.match(
      /^\[(.+?)\]\s*(->|->>|<-|<<-)\s*\[(.+?)\](?:\s*:\s*(\w+))?(?:\s*\((.+?)\))?$/
    );

    if (relationMatch) {
      const [, left, arrow, right, explicitType, relName] = relationMatch;
      let source, target, type = explicitType?.trim() || 'link';
      let cardinality;

      switch (arrow) {
        case '->>': source = left; target = right; cardinality = 'oneToMany'; break;
        case '<<-': source = right; target = left; cardinality = 'oneToMany'; break;
        case '->':  source = left; target = right; cardinality = 'oneToOne';  break;
        case '<-':  source = right; target = left; cardinality = 'oneToOne';  break;
      }

      source = source.trim();
      target = target.trim();

      nodes.add(source);
      nodes.add(target);

      const isSelfLoop = source === target;
      let shape_type = type === 'subtype' ? type : `${cardinality}-${type}`;
      if (isSelfLoop) shape_type += '-self';

      edges.push({
        data: {
          source,
          target,
          type: shape_type,
          rel_type: type,
          rel_name: relName,
          label: relName?.trim() || type
        }
      });

      return;
    }

    // å˜é …å¼ã®ãƒ‘ã‚¿ãƒ¼ãƒ³
    const nodeMatch = line.match(/^\[(.+?)\]$/);
    if (nodeMatch) {
      const nodeName = nodeMatch[1].trim();
      if (nodeName) nodes.add(nodeName);
    }
  });

  let isGenericType = false;

  return {
    nodes: Array.from(nodes).map(id => ({ data: { id, label: id, isGenericType: isGenericType } })),
    edges
  };
}

function parseModelText(text) {
  const lines = text.split('\n');
  const errors = [];

  lines.forEach((line, index) => {
    const lineNumber = index + 1;
    const trimmed = line.trim();

    if (trimmed.startsWith('#') || trimmed === '') return;

    // é–¢ä¿‚å¼ã®ãƒ‘ã‚¿ãƒ¼ãƒ³

    // å¼2ãƒ»å¼3å¯¾å¿œã®é–¢ä¿‚å¼ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼ˆrel_nameä»˜ãã‚‚è¨±å®¹ï¼‰
    const relationMatch = trimmed.match(
      /^\[(.+?)\]\s*(->|->>|<-|<<-)\s*\[(.+?)\](?:\s*:\s*(\w+))?(?:\s*\((.+?)\))?$/
    );

    if (relationMatch) {
      // é–¢ä¿‚å¼ã¨ã—ã¦æœ‰åŠ¹ãªã®ã§ã‚¨ãƒ©ãƒ¼ãªã—
      return;
    }

    // å¼1å¯¾å¿œã®å˜é …å¼ã®ãƒ‘ã‚¿ãƒ¼ãƒ³
    const nodeMatch = trimmed.match(/^\[(.+?)\]$/);
    if (nodeMatch) {
      // å˜é …å¼ã¨ã—ã¦æœ‰åŠ¹ãªã®ã§ã‚¨ãƒ©ãƒ¼ãªã—
      return;
    }

    // ã©ã¡ã‚‰ã«ã‚‚ãƒãƒƒãƒã—ãªã„å ´åˆã¯æ§‹æ–‡ã‚¨ãƒ©ãƒ¼
    errors.push({
      line: lineNumber,
      error: 'æ§‹æ–‡ã‚¨ãƒ©ãƒ¼',
      reason: 'è¡Œã®å½¢å¼ãŒæ­£ã—ãã‚ã‚Šã¾ã›ã‚“ã€‚ä¾‹: [A] -> [B]:type ã¾ãŸã¯ [ãƒãƒ¼ãƒ‰å]'
    });
  });

  return errors;
}

function showImportErrors(errors) {
  closeAllDialogs();
  console.log("showImportErrors called!!");
  console.log(errors);
  const container = document.getElementById('importErrorContainer');
  const list = document.getElementById('importErrorList');

  // åˆæœŸåŒ–
  list.innerHTML = '';
  container.style.display = 'block';

  errors.forEach(err => {
    const item = document.createElement('li');
    item.textContent = `${err.line}è¡Œç›®: ${err.error} - ${err.reason}`;
    list.appendChild(item);
  });
}

// idè‡ªå‹•ç”Ÿæˆ
function generateUniqueId(prefix = '') {
  return prefix + Math.random().toString(36).substr(2, 9);
}

function resetAttrDialog() {
  // ãƒœã‚¿ãƒ³ãƒ©ãƒ™ãƒ«ã‚’ã€Œè¿½åŠ ã€ã«æˆ»ã™
  document.getElementById('addAttr').textContent = 'è¿½åŠ ';
  editingAttrIndex = null;
}

let selectedNode;

// Nodeã‚¤ãƒ™ãƒ³ãƒˆã®è¨­å®šæ©Ÿèƒ½
function bindNodeEvents(cy) {
  cy.on('tap', 'node', evt => {
    closeNodeDialog();
    resetAttrDialog();//ãƒªã‚»ãƒƒãƒˆå‡¦ç†è¿½åŠ 
    const node = evt.target;
    selectedNode = node;
    selectedEdge = null;//é¸æŠã‚¨ãƒƒã‚¸ã‚’è§£æ”¾
    
    // Alt+ã‚¯ãƒªãƒƒã‚¯ â†’ ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼è¡¨ç¤º
    if (evt.originalEvent.altKey) {
      previewJson();   // â† ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ãƒœã‚¿ãƒ³ã‚¯ãƒªãƒƒã‚¯ã¨åŒã˜
      return;
    }

    document.getElementById('fieldEditor').style.display = 'block';
    openFieldEditor(node);
    updateAttrList(node.data().fields || []);
  });
}

// Edgeã‚¤ãƒ™ãƒ³ãƒˆã®è¨­å®šæ©Ÿèƒ½
function bindEdgeEvents(cy) {
  cy.on('tap', 'edge', function(evt){
    const edge = evt.target;
    selectedEdge = edge;
    selectedNode = null;//é¸æŠãƒãƒ¼ãƒ‰ã‚’è§£æ”¾

    console.log("Edge Click!!");
    closeAllDialogs();

    const sourceId = selectedEdge.data("source");
    const targetId = selectedEdge.data("target");
    const typeName = selectedEdge.data("type");

    document.getElementById("edgeSourceName").textContent  = sourceId || "";
    document.getElementById("edgeTargetName").textContent  = targetId || "";
    document.getElementById("edgeTypeName").textContent  = typeName || "";

    document.getElementById('edgeRelNameInput').value = edge.data("rel_name") || "";
    document.getElementById("edgeLabelInput").value = edge.data("label") || "";
    document.getElementById("edgeImplInput").value = edge.data("impl_name") || "";
    document.getElementById("edgeImplTypeInput").value = edge.data("impl_type") || "";

    const isSubtype = edge.data("type") === "subtype";
    document.getElementById("edgeRelNameInput").disabled = isSubtype;
    document.getElementById("edgeLabelInput").disabled = isSubtype;
    document.getElementById("edgeImplInput").disabled = isSubtype;
    document.getElementById("edgeImplTypeInput").disabled = isSubtype;
    document.getElementById("edgeImplTypeSelect").disabled = isSubtype;
    document.getElementById("edgeRequiredCheckbox").disabled = isSubtype;

    const edgeReqired = edge.data("required") || false;
    document.getElementById("edgeRequiredCheckbox").checked = edgeReqired;

    // conversionSection ã®è¡¨ç¤ºåˆ¶å¾¡
    if (edge.data("type") === "oneToOne-include" || edge.data("type") === "oneToMany-include" || edge.data("org_type")) {
      document.getElementById("conversionSection").style.display = "block";
      document.getElementById("conversionNotice").textContent = "";
    } else {
      document.getElementById("conversionSection").style.display = "none";
    }

    // âœ… å…±é€šé–¢æ•°ã§ projection_fields ã‚’æ›´æ–°
    const implType = edge.data("impl_type") || "";
    const match = implType.match(/^(array|object|\*object)<(.+)>$/);
    const targetName = match?.[2];
    const targetNode = cy_model.nodes().find(n => n.data("impl_name") === targetName);

    updateProjectionFieldsList(implType, targetNode, cy_model, edge);

    // âœ… *object<> ã®å ´åˆã¯ impl_name éè¡¨ç¤ºï¼‹ required ç„¡åŠ¹åŒ–
    const implInput = document.getElementById("edgeImplInput");
    const implLabel = document.getElementById("edgeImplLabel");

    const requiredCheckbox = document.getElementById("edgeRequiredCheckbox");

    // ã¾ãšé€šå¸¸ã® checked çŠ¶æ…‹ã‚’åæ˜ 
    const edgeRequired = edge.data("required") || false;
    requiredCheckbox.checked = edgeRequired;

    // implType ã«ã‚ˆã‚‹åˆ¶å¾¡
    if (implType.startsWith("*object<")) {
      implInput.value = "";
      implInput.style.display = "none";
      implLabel.style.display = "none";
      // â˜… è¿½åŠ ï¼šrequired ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ã‚’éè¡¨ç¤º
      requiredCheckbox.closest("label").style.display = "none";


    } else {
      implInput.style.display = "block";
      implLabel.style.display = "block";
      // â˜… è¿½åŠ ï¼šé€šå¸¸æ™‚ã¯è¡¨ç¤º
      requiredCheckbox.closest("label").style.display = "block";

    }

    // subtype ã®å ´åˆã¯æœ€å„ªå…ˆã§ç„¡åŠ¹åŒ–
    if (isSubtype) {
      requiredCheckbox.checked = false;
      requiredCheckbox.disabled = true;
    }

    document.getElementById("edgeEditPanel").style.display = "block";
  });
}
let cy_model;
let model_st = [
  // å…±é€šã‚¹ã‚¿ã‚¤ãƒ«
  {
    selector: 'node',
    style: {
      'shape': 'rectangle',
      'width': 'label',
      'height': 'label',
      'padding': '10px',
      'label': 'data(label)',
      'color': '#fff',
      'font-size': '10px',
      'text-valign': 'center',
      'text-halign': 'center'
    }
  },
  {
    selector: 'node[isGenericType]',
    style: {
      'background-color': '#88c'
    }
  },
  {
    selector: 'node[!isGenericType]',
    style: {
      'background-color': '#555'
    }
  },


  // æ±ç”¨ã‚¨ãƒƒã‚¸ã‚¹ã‚¿ã‚¤ãƒ«ï¼ˆrefï¼‰
  {
    selector: 'edge[type = "oneToMany-ref"]',
    style: {
      'curve-style': 'bezier',
      'font-size': '8px',
      'text-background-color': '#f4f4f4',
      'text-background-opacity': 1,
      'text-background-padding': 2,
      'line-style': 'dashed',
      'line-color': '#666',
      'target-arrow-shape': 'triangle',
      'target-arrow-color': '#666'
    }
  },
  {
    selector: 'edge[type = "oneToOne-ref"]',
    style: {
      'curve-style': 'bezier',
      'font-size': '8px',
      'text-background-color': '#f4f4f4',
      'text-background-opacity': 1,
      'text-background-padding': 2,
      'line-style': 'dashed',
      'line-color': '#666',
      'target-arrow-shape': 'chevron',
      'target-arrow-color': '#666'
    }
  },
  // æ±ç”¨ã‚¨ãƒƒã‚¸ã‚¹ã‚¿ã‚¤ãƒ«ï¼ˆincludeï¼‰
  {
    selector: 'edge[type = "oneToMany-include"]',
    style: {
      'curve-style': 'bezier',
      'font-size': '8px',
      'text-background-color': '#f4f4f4',
      'text-background-opacity': 1,
      'text-background-padding': 2,
      'line-style': 'solid',
      'line-color': '#007acc',
      'target-arrow-shape': 'triangle',
      'target-arrow-color': '#666'
    }
  },
  {
    selector: 'edge[type = "oneToOne-include"]',
    style: {
      'curve-style': 'bezier',
      'font-size': '8px',
      'text-background-color': '#f4f4f4',
      'text-background-opacity': 1,
      'text-background-padding': 2,
      'line-style': 'solid',
      'line-color': '#007acc',
      'target-arrow-shape': 'chevron',
      'target-arrow-color': '#666'
    }
  },
  // æ±ç”¨ã‚¨ãƒƒã‚¸ã‚¹ã‚¿ã‚¤ãƒ«ï¼ˆlinkï¼‰
  {
    selector: 'edge[type = "oneToMany-link"]',
    style: {
      'curve-style': 'bezier',
      'font-size': '8px',
      'text-background-color': '#f4f4f4',
      'text-background-opacity': 1,
      'text-background-padding': 2,
      'line-style': 'solid',
      'line-color': '#666',
      'target-arrow-shape': 'triangle',
      'target-arrow-color': '#666'
    }
  },
  {
    selector: 'edge[type = "oneToOne-link"]',
    style: {
      'curve-style': 'bezier',
      'font-size': '8px',
      'text-background-color': '#f4f4f4',
      'text-background-opacity': 1,
      'text-background-padding': 2,
      'line-style': 'solid',
      'line-color': '#666',
      'target-arrow-shape': 'chevron',
      'target-arrow-color': '#666'
    }
  },
  // æ±ç”¨ã‚¨ãƒƒã‚¸ã‚¹ã‚¿ã‚¤ãƒ«ï¼ˆref-selfï¼‰
  {
    selector: 'edge[type = "oneToMany-ref-self"]',
    style: {
      'curve-style': 'bezier',
      'loop-direction': 'right',
      'loop-sweep': 100,
      'line-style': 'dashed',
      'line-color': '#666',
      'target-arrow-shape': 'triangle',
      'target-arrow-color': '#666',
      'font-size': '8px'
    }
  },
  {
    selector: 'edge[type = "oneToOne-ref-self"]',
    style: {
      'curve-style': 'bezier',
      'loop-direction': 'right',
      'loop-sweep': 100,
      'line-style': 'dashed',
      'line-color': '#666',
      'target-arrow-shape': 'chevron',
      'target-arrow-color': '#666',
      'font-size': '8px'
    }
  },
  {
      // æ±ç”¨ã‚¨ãƒƒã‚¸ã‚¹ã‚¿ã‚¤ãƒ«ï¼ˆåŸºæœ¬ãƒ©ãƒ™ãƒ«ã¨é…ç½®ã®ã¿ï¼‰
      selector: 'edge',
      style: {
        'curve-style': 'bezier',
        'label': 'data(label)',
        'font-size': '8px',
        'text-background-color': '#f4f4f4',
        'text-background-opacity': 1,
        'text-background-padding': 2
      }
  },
  {
      selector: 'edge[type = "subtype"]',
      style: {
        'line-style': 'solid',
        'line-color': '#2e7d32',
        'target-arrow-color': '#2e7d32',
        'target-arrow-shape': 'triangle-backcurve',
        'width': 2
      }
  },
  {
    selector: 'node:selected',
    style: {
      'border-width': 3,
      'border-color': '#f39c12',
    }
  },
  {
    selector: 'edge:selected',
    style: {
      'line-color': '#f39c12',
      'target-arrow-color': '#f39c12',
      'width': 3
    }
  }
];

let data = {
    "nodes": [],
    "edges": []
};
const cy = cytoscape({
  container: document.getElementById('cy'),
  elements: data,
  style: model_st,
  layout: {
    name: 'dagre',
    rankDir: 'LR',
    nodeSep: 60,
    edgeSep: 30,
    rankSep: 100
  },
  wheelSensitivity: 0.2 // â† ã“ã‚ŒãŒã‚ºãƒ¼ãƒ æ„Ÿåº¦
});

cy_model = cy;

cy_model.on('tap', 'node, edge', function(evt) {
  cy_model.elements().unselect(); // ä»–ã®é¸æŠè§£é™¤
  lastClickPosition = { x: evt.x, y: evt.y };
  evt.target.select();            // ã“ã®è¦ç´ ã ã‘é¸æŠ
});

bindNodeEvents(cy_model);
bindEdgeEvents(cy_model);

// ä¿å­˜ãƒœã‚¿ãƒ³æ©Ÿèƒ½
function generateFilename(formatName, modelName) {
  const now = new Date();
  const yyyy = now.getFullYear();
  const mm = String(now.getMonth() + 1).padStart(2, '0');
  const dd = String(now.getDate()).padStart(2, '0');
  const hh = String(now.getHours()).padStart(2, '0');
  const min = String(now.getMinutes()).padStart(2, '0');
  return `${formatName}-${modelName}-${yyyy}${mm}${dd}-${hh}${min}.json`;
}

// JSON graph ä¿å­˜
document.getElementById('save').addEventListener('click', async () => {
  try {
    const input = document.getElementById('modelNameInput');
    if (input && input.value.trim()) {
      currentModelName = input.value.trim(); // ãƒ¢ãƒ‡ãƒ«åã‚’ä¿æŒ
    }

    const suggestedName = generateFilename('json-graph', currentModelName);
    const fileHandle = await window.showSaveFilePicker({
      suggestedName: suggestedName, //'cy-positioned.json',
      types: [{
        description: 'json file',
        accept: { 'application/json': ['.json'] }
      }]
    });

    const json = cy_model.elements().jsons();
    const writable = await fileHandle.createWritable();
    const content = JSON.stringify(json, null, 2);// ã“ã“ã«ä¿å­˜ã—ãŸã„ãƒ†ã‚­ã‚¹ãƒˆã‚’å…¥ã‚Œã‚‹
    await writable.write(content);
    await writable.close();
    console.log('ä¿å­˜å®Œäº†:', fileHandle.name);
  } catch (err) {
    if (err.name !== 'AbortError') {
      console.error('ä¿å­˜ã‚¨ãƒ©ãƒ¼:', err);
    }
  }
  closeAllMenus();
});

//ä»¥ä¸‹å±æ€§è¨­å®šãƒ€ã‚¤ã‚¢ãƒ­ã‚°ç”¨

// ãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã‚¯ãƒ­ãƒ¼ã‚ºå‡¦ç† -- start 
const dialogIds = [
  'importErrorContainer',
  'fieldEditor',
  'nodeDialog',
  'edgeDialog',
  'implEditor',
  'edgeEditPanel',
  'conversionSection',
  'conversionNotice',
  'typeModal',
  'modalOverlay',
  'previewDialog'
];

function closeAllDialogs() {
  closeAllMenus(); //ãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã‚’é–‰ã˜ã‚‹ã¨ãã«ã‚µãƒ–ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‚‚ã™ã¹ã¦é–‰ã˜ã‚‹
  dialogIds.forEach(id => {
    const el = document.getElementById(id);
    if (el) el.style.display = 'none';
  });
}
// ãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã‚¯ãƒ­ãƒ¼ã‚ºå‡¦ç† -- end 

function updateAttrList(fields) {
const list = document.getElementById('attrList');
list.innerHTML = '<ul>' + fields.map((f, i) =>
`<li>
  <strong>${f.name}</strong> (${f.type}) ${f.required ? '[å¿…é ˆ]' : ''} ${f.discriminator ? '[D]' : ''}  ${f.identifier ? '[I]' : ''}
  ${f.desc ? `<div style="font-size:10px;color:#666;">èª¬æ˜: ${f.desc}</div>` : ''}
  <button onclick="moveAttr(${i}, -1)">â–²</button>
  <button onclick="moveAttr(${i}, 1)">â–¼</button>
  <button onclick="editAttr(${i})">âœ ç·¨é›†</button>
  <button onclick="removeAttr(${i})">ğŸ—‘ å‰Šé™¤</button>
</li>`
).join('') + '</ul>';
}

function removeAttr(index) {
	const nodeData = selectedNode.data();
	nodeData.fields.splice(index, 1);
	updateAttrList(nodeData.fields);
}

let editingIndex = null;

function editAttr(index) {
	const field = selectedNode.data().fields[index];
	document.getElementById('attrName').value = field.name;
	document.getElementById('attrType').value = field.type;
	document.getElementById('attrDesc').value = field.desc || '';
	document.getElementById('attrRequired').checked = field.required || false;
  document.getElementById('attrDiscriminator').checked = field.discriminator || false;
  document.getElementById('attrIdentifier').checked = field.identifier || false;
	editingIndex = index;

	document.getElementById('addAttr').textContent = 'ä¿å­˜';
}

document.getElementById('closeEditor').addEventListener('click', () => {
	document.getElementById('fieldEditor').style.display = 'none';
	});

function moveAttr(index, direction) {
	const fields = selectedNode.data().fields || [];
	const newIndex = index + direction;

	if (newIndex < 0 || newIndex >= fields.length) return; // ç¯„å›²å¤–ã¯ç„¡è¦–

	// å…¥ã‚Œæ›¿ãˆï¼ˆã‚·ãƒ³ãƒ—ãƒ«ãªé…åˆ—swapï¼‰
	[fields[index], fields[newIndex]] = [fields[newIndex], fields[index]];

	updateAttrList(fields);
}

document.getElementById('addAttr').addEventListener('click', () => {
	const name = document.getElementById('attrName').value.trim();
	let type = document.getElementById('attrType').value.trim();
	const desc = document.getElementById('attrDesc').value.trim();
	let required = document.getElementById('attrRequired').checked;
  const discriminator = document.getElementById('attrDiscriminator')?.checked;
  const identifier = document.getElementById('attrIdentifier')?.checked;

	if (!name || !type) return;

  if (discriminator){ //ã“ã“ã«å‡¦ç†ã‚’æ›¸ã
    if (type !== 'string') {
      const ok = window.confirm(
        'discriminator ã¯ string å‹ã§æŒ‡å®šã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚\nå‹ã‚’ string ã«å¤‰æ›´ã—ã¦ç¶šè¡Œã—ã¾ã™ã‹ï¼Ÿ'
      );

      if (ok) {
        // å‹ã‚’ string ã«å¼·åˆ¶å¤‰æ›´
        document.getElementById('attrType').value = 'string';
        type = 'string';
      } else {
        // ãƒã‚§ãƒƒã‚¯ã‚’å…ƒã«æˆ»ã—ã¦å‡¦ç†ä¸­æ–­
        document.getElementById('attrDiscriminator').checked = false;
        return;
      }
    }
  }
  // discriminatorãŒè¨­å®šã•ã‚Œã¦ã„ã‚‹å ´åˆã¯ã€å¿…é ˆ(required)ã¨ã™ã‚‹ã€‚2025-11-20
  if (discriminator) {
    required = true;
    document.getElementById('attrRequired').checked = true;
  }

  const field = {
    name,
    type,
    desc,
    required,
    discriminator,
    identifier
  };

	const fields = selectedNode.data().fields || [];

	if (editingIndex !== null) {
	  fields[editingIndex] = field; // ç·¨é›†æ›´æ–°
	  editingIndex = null;
	  document.getElementById('addAttr').textContent = 'è¿½åŠ ';
	} else {
	  fields.push(field); // æ–°è¦è¿½åŠ 
	}

	selectedNode.data().fields = fields;
	updateAttrList(fields);
});

// ãƒãƒ¼ãƒ‰æ–°è¦è¿½åŠ 
function openNodeDialog() {
  closeAllDialogs();
	document.getElementById('nodeDialog').style.display = 'block';
}

function closeNodeDialog() {
	document.getElementById('nodeDialog').style.display = 'none';
}

let lastClickPosition = { x: 100, y: 100 };
setupClickPositionTracking();

// é¸æŠã•ã‚ŒãŸã‚¢ã‚¤ãƒ†ãƒ ã‚’ã‚¯ãƒªã‚¢
function clear_selected_items(){
  selectedNode = null;
  selectedEdge = null;
}

// ç”»é¢ã‚¯ãƒªãƒƒã‚¯ä½ç½®ã‚’ä¿å­˜ã™ã‚‹ãƒãƒ³ãƒ‰ãƒ©
function setupClickPositionTracking() {
  cy_model.on('tap', function(event) {
    if (event.target === cy_model || event.target.group === undefined) {
      lastClickPosition = event.position;
      console.log("tap !!!");
      console.log(lastClickPosition);
      clear_selected_items(); // é¸æŠã•ã‚Œã¦ã„ãŸã‚¢ã‚¤ãƒ†ãƒ ã®é¸æŠè§£é™¤
      closeAllDialogs(); // â˜… ã“ã‚Œã‚’è¿½åŠ 
    }
  });
}

function createNodeAuto(name, isGenericType) {

  if (cy_model.getElementById(name).length > 0) {
    alert(`ãƒãƒ¼ãƒ‰ã€Œ${name}ã€ã¯ã™ã§ã«å­˜åœ¨ã—ã¾ã™`);
    return;
  }

  let node = {
	  group: 'nodes',
	  data: {
      id: name,
		  label: name,
		  fields: [],
      isGenericType: isGenericType
	  },
    position: lastClickPosition
  };

  lastClickPosition = { x: lastClickPosition.x + 1, y: lastClickPosition.y + 1 };
  
  cy_model.add(node);

}

function createNode() {

	const name = document.getElementById('nodeName').value.trim();
	if (!name) return;
  const isGenericType = document.getElementById('isGenericType').checked;

	createNodeAuto(name, isGenericType);

	closeNodeDialog();
}

function filterNodes(query) {
query = query.trim().toLowerCase();

const rows = document.querySelectorAll('#implTable tr');
rows.forEach((row, index) => {
  // ãƒ˜ãƒƒãƒ€ãƒ¼è¡Œã¯å¸¸ã«è¡¨ç¤º
  if (index === 0) {
	row.style.display = '';
	return;
  }

  const label = row.cells[0].textContent.toLowerCase();
  const impl = row.cells[1].querySelector('input')?.value.toLowerCase();

  if (label.includes(query) || impl.includes(query)) {
	  row.style.display = '';
  } else {
	  row.style.display = 'none';
  }
});
}

function openFieldEditor(node) {
  closeAllDialogs();
	document.getElementById("fieldEditor").style.display = "block";
	document.getElementById("nodeLabelText").textContent = node.data("label") || "(æœªè¨­å®š)";
	document.getElementById("nodeImplText").textContent = node.data("impl_name") || "(æœªè¨­å®š)";
  const isGenericType = node.data('isGenericType');
  document.getElementById('nodeGenericText').textContent = isGenericType ? 'true' : 'false';

}

// èª­ã¿è¾¼ã¿ãƒœã‚¿ãƒ³ãŒæŠ¼ã•ã‚ŒãŸã‚‰ãƒ•ã‚¡ã‚¤ãƒ«é¸æŠãƒ€ã‚¤ã‚¢ãƒ­ã‚°è¡¨ç¤º
document.getElementById('load').addEventListener('click', () => {
	document.getElementById('fileInput').click();
  closeAllMenus();
	});

// ãƒ•ã‚¡ã‚¤ãƒ«åã‹ã‚‰ãƒ¢ãƒ‡ãƒ«åã‚’æŠ½å‡ºã™ã‚‹
function extractModelName(file) {
  const name = typeof file === 'string' ? file : file.name;
  const match = name.match(/^json-graph-(.+?)-\d{8}-\d{4}\.json$/);
  return match ? match[1] : '';
}

// ãƒ•ã‚¡ã‚¤ãƒ«ãŒé¸ã°ã‚ŒãŸã‚‰ JSON èª­ã¿è¾¼ã¿ã—ã¦ã‚°ãƒ©ãƒ•å†è¡¨ç¤º
document.getElementById('fileInput').addEventListener('change', event => {
  const file = event.target.files[0];
  if (!file) return;
  // ãƒ¢ãƒ‡ãƒ«åæ¬„ã«è¨­å®š
  const model_name = extractModelName(file);
  document.getElementById('modelNameInput').value = model_name;

  const reader = new FileReader();
  reader.onload = e => {
    try {
      const json = JSON.parse(e.target.result);
      if (cy_model) {
        cy_model.off('tap');         // å…¨ãƒãƒ¼ãƒ‰ãƒ»ã‚¨ãƒƒã‚¸ã«å¯¾ã™ã‚‹ tap ã‚¤ãƒ™ãƒ³ãƒˆã‚’è§£é™¤
        cy_model.off('click');       // click ã‚¤ãƒ™ãƒ³ãƒˆã‚’è§£é™¤
        cy_model.off('mouseover');   // å¿…è¦ã«å¿œã˜ã¦ä»–ã®ã‚¤ãƒ™ãƒ³ãƒˆã‚‚

        cy_model.destroy();
        cy_model = null;
      }

      cy_model = cytoscape({
        container: document.getElementById('cy'),
        elements: json,
        style: model_st, // æ—¢å­˜ã‚¹ã‚¿ã‚¤ãƒ«é…åˆ—
        layout: { name: 'preset' }, // â† ä¿å­˜ã•ã‚ŒãŸä½ç½®ã§è¡¨ç¤ºï¼
        wheelSensitivity: 0.2 // â† ã“ã‚ŒãŒã‚ºãƒ¼ãƒ æ„Ÿåº¦
      });
      bindNodeEvents(cy_model);
      bindEdgeEvents(cy_model);
      setupClickPositionTracking();
      cy_model.elements().unselect();

    } catch (err) {
      console.error('âŒ JSONèª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼:', err);
      alert('JSONãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ');
    }
  };
  reader.readAsText(file);

  // ğŸ” åŒã˜ãƒ•ã‚¡ã‚¤ãƒ«ã§ã‚‚å†é¸æŠã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹
  event.target.value = '';

  // ãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã‚’éè¡¨ç¤ºã«ã™ã‚‹
  closeAllDialogs();
});

// ESCã‚­ãƒ¼ã§é¸æŠè§£é™¤ã™ã‚‹æ“ä½œã‚‚è¿½åŠ å¯èƒ½
document.addEventListener('keydown', function(e) {
  if (e.key === 'Escape') {
    clearSelection();
  }
});

//ã‚¨ãƒƒã‚¸è¿½åŠ 
function openEdgeDialog() {
  closeAllDialogs();
  const sourceSelect = document.getElementById('edgeSource');
  const targetSelect = document.getElementById('edgeTarget');
  const nodes = cy_model.nodes();

  sourceSelect.innerHTML = '';
  targetSelect.innerHTML = '';

  nodes.forEach(n => {
    const id = n.id();
    const label = n.data('label') || id;
    const isGeneric = n.data('isGenericType') === true;
    const displayLabel = isGeneric ? `[type] ${label}` : label;

    const optionSource = document.createElement('option');
    optionSource.value = id;
    optionSource.textContent = displayLabel;
    optionSource.className = isGeneric ? 'generic' : 'non-generic';
    sourceSelect.appendChild(optionSource);

    const optionTarget = document.createElement('option');
    optionTarget.value = id;
    optionTarget.textContent = displayLabel;
    optionTarget.className = isGeneric ? 'generic' : 'non-generic';
    targetSelect.appendChild(optionTarget);
  });

  document.getElementById('edgeDialog').style.display = 'block';
}

function closeEdgeDialog() {
  document.getElementById('edgeDialog').style.display = 'none';
}

function createEdge() {
  const nodes = cy_model.nodes();
  if (nodes.length < 2) {
    alert("ãƒãƒ¼ãƒ‰ãŒ2ã¤ä»¥ä¸Šå­˜åœ¨ã—ã¦ã„ãªã„ãŸã‚ã€ã‚¨ãƒƒã‚¸ã‚’ä½œæˆã§ãã¾ã›ã‚“ã€‚");
    return;
  }

  const source = document.getElementById('edgeSource').value;
  const target = document.getElementById('edgeTarget').value;

  // åˆ¶åº¦çš„æ•´åˆæ€§ãƒã‚§ãƒƒã‚¯
  const sourceNode = cy_model.getElementById(source);
  const targetNode = cy_model.getElementById(target);
  const sourceGeneric = sourceNode.data('isGenericType') === true;
  const targetGeneric = targetNode.data('isGenericType') === true;

  if (sourceGeneric !== targetGeneric) {
    alert("GenericTypeãƒãƒ¼ãƒ‰ã¨å®Ÿä½“ãƒãƒ¼ãƒ‰ã®æ¥ç¶šã¯ã§ãã¾ã›ã‚“ã€‚");
    return;
  }

  // ä»¥ä¸‹ã€æ—¢å­˜ã®å‡¦ç†ã‚’ãã®ã¾ã¾ç¶šè¡Œ
  const type = document.getElementById('edgeType').value;
  const cardinality = document.getElementById('edgeCardinality').value;
  let relName = document.getElementById('edgeRelName').value.trim();

  let shape_type = '';
  if (type === 'subtype') {
    shape_type = 'subtype';
    relName = '';
  } else {
    shape_type = (cardinality === '1:N') ? 'oneToMany' : 'oneToOne';
    shape_type = `${shape_type}-${type}`;
  }

  const isSelfLoop = source === target;
  if (isSelfLoop) shape_type += '-self';

  const autoId = generateUniqueId('edge-');
  cy_model.add({
    group: 'edges',
    data: {
      id: autoId,
      source, target,
      type: shape_type,
      rel_type: type,
      rel_name: relName,
      label: type
    }
  });

  graphLabelUpdate();
  graphNodeLabelUpdate();
  closeEdgeDialog();
}

// å‰Šé™¤æ©Ÿèƒ½
function deleteSelected() {
  const selected = cy_model.$(':selected');
  if (selected.length === 0) {
    alert("å‰Šé™¤ã—ãŸã„ãƒãƒ¼ãƒ‰ã¾ãŸã¯ã‚¨ãƒƒã‚¸ã‚’é¸æŠã—ã¦ãã ã•ã„");
    return;
  }
  cy_model.remove(selected);
  // å‰Šé™¤å¾Œå‡¦ç†
  closeAllDialogs();
  clearSelection();

}

// é¸æŠè§£é™¤
function clearSelection() {
  selectedNode = null;
  selectedEdge = null;
  cy_model.elements().unselect();
}

// ã‚¨ãƒƒã‚¸ãƒ©ãƒ™ãƒ«è¡¨ç¤ºè¨­å®šå–å¾—
let currentLabelMode = 'default';
document.getElementById('labelModeSelect').addEventListener('change', function() {
  currentLabelMode = this.value;
  updateEdgeLabels(currentLabelMode);
});

function graphLabelUpdate(){
  console.log("called graphLabelUpdate()")
  updateEdgeLabels(currentLabelMode);
}

// ãƒãƒ¼ãƒ‰ãƒ©ãƒ™ãƒ«è¡¨ç¤ºè¨­å®šå–å¾—
let currentNodeLabelMode = 'default';
document.getElementById('nodeLabelModeSelect').addEventListener('change', function() {
  const edgeLabelSelect = document.getElementById("labelModeSelect"); // ã‚¨ãƒƒã‚¸ã®ãƒ©ãƒ™ãƒ«ã‚³ãƒ³ãƒœ

  currentNodeLabelMode = this.value;
  updateNodeLabels(currentNodeLabelMode);
  
  // GUIä¸Šã®ã‚¨ãƒƒã‚¸ãƒ‰ãƒ­ãƒƒãƒ—ãƒ€ã‚¦ãƒ³ã‚‚é€£å‹•
  edgeLabelSelect.value = this.value;
  edgeLabelSelect.dispatchEvent(new Event("change"));// ã‚¤ãƒ™ãƒ³ãƒˆç™ºç«

});

function graphNodeLabelUpdate(){
  console.log("called graphNodeLabelUpdate()")
  updateNodeLabels(currentNodeLabelMode);
}


//ãƒãƒ¼ãƒ‰ãƒ©ãƒ™ãƒ«è¡¨ç¤ºè¨­å®š
function updateNodeLabels(mode = 'default') {
  cy_model.nodes().forEach(node => {
    let label = '';
    switch (mode) {
      case 'default':
        label = node.data('id');
        break;
      case 'impl_name':
        label = node.data('impl_name')?.trim();
        label = label ? label : '<undefined>';
        break;
    }

    node.data('label', label);
  });
}

//ã‚¨ãƒƒã‚¸ãƒ©ãƒ™ãƒ«è¡¨ç¤ºè¨­å®šã€€2026-01-15
function updateEdgeLabels(mode = 'default') {
  cy_model.edges().forEach(edge => {
    let label = '';
    if (edge.data('rel_type') === 'subtype') {
      label = 'subtype';
    } else {
      switch (mode) {
        case 'type':
          label = edge.data('rel_type') || '';
          break;
        case 'impl_name':
          let impl = edge.data('impl_name')?.trim();

          if (!impl) {
            if (edge.data('impl_type')?.startsWith('*object')) {
              label = '<by projection>'; // *object<>ã®æ™‚ã«ã€<by projection>è¡¨ç¤º
            } else {
              label = '<undefined>';
            }
          } else {
            label = impl;
          }
          break;
        case 'default':
          label = edge.data('rel_name')?.trim() || edge.data('rel_type') || '';
          break;
      }
    }

    edge.data('label', label);
  });
}

// å®Ÿè£…åè¨­å®š

function openImplEditor() {
  closeAllDialogs();

  const table = document.getElementById('implTable');
  table.innerHTML = '<tr><th>è«–ç†åï¼ˆlabelï¼‰</th><th>å®Ÿè£…åï¼ˆimpl_nameï¼‰</th></tr>';

  cy_model.nodes().forEach(node => {
    const label = node.data('label') || node.data('id');
    const current = node.data('impl_name') || '';
    const isGeneric = node.data('isGenericType') === true;
    const displayLabel = isGeneric ? `[type] ${label}` : label;

    const inputField = `<input value="${current}" data-id="${node.id()}" class="impl-input" placeholder="${isGeneric ? 'å‹å' : 'å®Ÿè£…å'}">`;

    const row = `<tr class="${isGeneric ? 'generic-row' : 'non-generic-row'}">
      <td>${displayLabel}</td>
      <td>${inputField}</td>
    </tr>`;

    table.innerHTML += row;
  });

  document.getElementById('implEditor').style.display = 'block';
}

// å‹é¸æŠGUI(ã‚¨ãƒƒã‚¸ç”¨)
function updateReferenceFieldVisibility(dataType) {
  const refField = document.getElementById("projectionFieldsSection");
  if (!refField) return; // è¦ç´ ãŒå­˜åœ¨ã—ãªã„å ´åˆã¯ä½•ã‚‚ã—ãªã„

  if (
    dataType.startsWith("array<") ||
    dataType.startsWith("object<") ||
    dataType.startsWith("*object<")
  ) {
    refField.style.display = "block";
  } else {
    refField.style.display = "none";
  }
}

function updateProjectionFieldsList(finalType, targetNode, cy_model, edge) {
  const section = document.getElementById("projectionFieldsSection");
  const list = document.getElementById("projectionFieldsList");
  list.innerHTML = "";

  if (!edge || !targetNode) {
    section.style.display = "none";
    return;
  }
  if (edge.data("rel_type") !== "ref") {
    section.style.display = "none";
    return;
  }

  if (edge.data("rel_type") !== "ref" || !targetNode) {
    section.style.display = "none";
    return;
  }

  let nativeFields = [];
  let derivedFields = [];

  // 1) targetNode ã®ç›´æ¥å±æ€§
  (targetNode.data("fields") || []).forEach(f => {
    nativeFields.push({ name: f.name, origin: "native" });
  });

  // 2) targetNode ã‚’ source ã¨ã™ã‚‹ã‚¨ãƒƒã‚¸
  const outgoingEdges = cy_model.edges().filter(e => e.data("source") === targetNode.data("id"));
  outgoingEdges.forEach(e => {
    const implTypeE = e.data("impl_type") || "";

    if (implTypeE.startsWith("*object<")) {
      const pf = e.data("projection_fields") || [];
      pf.forEach(p => {
        derivedFields.push({ name: p.as || p.from, origin: "*object" });
      });
    } else if (implTypeE.startsWith("object<") || implTypeE.startsWith("array<")) {
      const implNameE = e.data("impl_name");
      if (implNameE) {
        derivedFields.push({ name: implNameE, origin: "object/array" });
      }
    }
  });

  const projectionFields = edge.data("projection_fields") || [];

  // 3) UI å‡ºåŠ›: native å±æ€§
  if (nativeFields.length > 0) {
    const header = document.createElement("div");
    header.textContent = "ğŸ”¹ å‚ç…§å…ˆå±æ€§ãƒãƒƒãƒ”ãƒ³ã‚°";
    header.style.fontWeight = "bold";
    list.appendChild(header);

    nativeFields.forEach(field => {
      const existing = projectionFields.find(p => p.from === field.name);
      const checked = existing ? "checked" : "";
      const asValue = existing?.as || "";
      const required = existing?.required || false;
      const requiredChecked = required ? "checked" : "";

      const div = document.createElement("div");
      div.className = "projectionFieldItem";
      div.innerHTML = `
        <label><input type="checkbox" data-from="${field.name}" ${checked} /> ${field.name}</label>
        â†’ as: <input type="text" data-as="${field.name}" value="${asValue}" placeholder="ä¾‹: åˆ¥å" />
        å¿…é ˆ: <input type="checkbox" data-required="${field.name}" ${requiredChecked} />
      `;
      list.appendChild(div);
    });
  }

  // 4) UI å‡ºåŠ›: æ´¾ç”Ÿå±æ€§
  if (derivedFields.length > 0) {
    const header = document.createElement("div");
    header.textContent = "ğŸ”¹ æ´¾ç”Ÿå±æ€§";
    header.style.fontWeight = "bold";
    list.appendChild(header);

    derivedFields.forEach(field => {
      const existing = projectionFields.find(p => p.from === field.name);
      const checked = existing ? "checked" : "";
      const asValue = existing?.as || "";
      const required = existing?.required || false;
      const requiredChecked = required ? "checked" : "";

      const div = document.createElement("div");
      div.className = "projectionFieldItem derived";
      div.innerHTML = `
        <label><input type="checkbox" data-from="${field.name}" ${checked} /> ${field.name} <span style="color:gray">(${field.origin})</span></label>
        â†’ as: <input type="text" data-as="${field.name}" value="${asValue}" placeholder="ä¾‹: åˆ¥å" />
        å¿…é ˆ: <input type="checkbox" data-required="${field.name}" ${requiredChecked} />
      `;
      list.appendChild(div);
    });
  }

  section.style.display = "block";
}

// å‹é¸æŠGUI(ãƒãƒ¼ãƒ‰ãƒ»ã‚¨ãƒƒã‚¸å…±é€š)
function openTypeSelector(setElem, isEdge = false) {
  const container = document.getElementById("typeOptions");
  container.innerHTML = ""; // åˆæœŸåŒ–

  const types = isEdge
  ? ["string", "number", "integer", "boolean", "null", "object", "array<>", "object<>","*object<>"]
  : ["string", "number", "integer", "boolean", "null", "object", "array<>", "object<>"];

  const relType = selectedEdge?.data("rel_type");
  if (relType === "subtype") {
    // ãªã«ã‚‚ã—ãªã„
    return;
  }

  let targetImplName = "";
  let targetNode = null;
  if (isEdge && selectedEdge) {
    let edge = selectedEdge;
    const targetId = edge.data("target");
    targetNode = cy_model.nodes().find(n => n.data("id") === targetId);
    targetImplName = targetNode?.data("impl_name") || "";
  }

  types.forEach(type => {
    const btn = document.createElement("button");
    btn.textContent = type;
    btn.style.padding = "4px 8px";
    
    btn.onclick = () => {
      let finalType = type;
      if ((type === "array<>" || type === "object<>" || type === "*object<>") && targetImplName !== "") {
        finalType = type.replace("<>", `<${targetImplName}>`);
      }

      document.getElementById(setElem).value = finalType;

      // âœ… å…±é€šãƒ­ã‚¸ãƒƒã‚¯ã§ projection_fields ã‚’æ›´æ–°
      updateReferenceFieldVisibility(finalType);
      updateProjectionFieldsList(finalType, targetNode, cy_model, selectedEdge);

      // impl_name å…¥åŠ›æ¬„ã®åˆ¶å¾¡
      const implInput = document.getElementById("edgeImplInput");
      const implLabel = document.getElementById("edgeImplLabel");
      const requiredCheckbox = document.getElementById("edgeRequiredCheckbox");
      const requiredLabel = requiredCheckbox.closest("label");

      if (isEdge && selectedEdge && finalType.startsWith("*object<")) {
        selectedEdge.data("impl_name", "");
        implInput.value = "";
        implInput.style.display = "none";
        implLabel.style.display = "none";

        // â˜… è¿½åŠ ï¼šå¿…é ˆãƒã‚§ãƒƒã‚¯ã‚’éè¡¨ç¤ºã«ã™ã‚‹
        requiredLabel.style.display = "none";

        // âœ… å¿…é ˆãƒã‚§ãƒƒã‚¯ã‚’å®Œå…¨ã«ç„¡åŠ¹åŒ–
        requiredCheckbox.checked = false;
        requiredCheckbox.disabled = true;
      } else {
        implInput.style.display = "block";
        implLabel.style.display = "block";

        // â˜… è¿½åŠ ï¼šé€šå¸¸å‹ã«æˆ»ã—ãŸã‚‰å†è¡¨ç¤º
        requiredLabel.style.display = "inline-block";

        requiredCheckbox.disabled = false;
      }

      closeTypeModal();
    };
    container.appendChild(btn);
  });

  document.getElementById("modalOverlay").style.display = "block";//ãƒ¢ãƒ¼ãƒ€ãƒ«èƒŒæ™¯
  document.getElementById("typeModal").style.display = "block";
}

function closeTypeModal() {
  document.getElementById("typeModal").style.display = "none";
  document.getElementById("modalOverlay").style.display = "none";//ãƒ¢ãƒ¼ãƒ€ãƒ«èƒŒæ™¯
}

function saveImplNames() {
  const inputs = document.querySelectorAll('.impl-input');
  inputs.forEach(input => {
    const id = input.getAttribute('data-id');
    const node = cy_model.getElementById(id);
    node.data('impl_name', input.value.trim());
  });

  // ç¾åœ¨ã®ãƒ©ãƒ™ãƒ«è¡¨ç¤ºãƒ¢ãƒ¼ãƒ‰ã§ä¸€æ‹¬è¨­å®š
  graphLabelUpdate();
  graphNodeLabelUpdate();
  showToast("ãƒãƒ¼ãƒ‰å®Ÿè£…åã‚’ä¿å­˜ã—ã¾ã—ãŸï¼");
  closeImplEditor();
}

function closeImplEditor() {
  document.getElementById('implEditor').style.display = 'none';
}

//ã‚¨ãƒƒã‚¸åè¨­å®š
let selectedEdge = null;

function saveEdgeProperties() {
  if (!selectedEdge) return;

  const label = document.getElementById("edgeLabelInput").value;
  const relName = document.getElementById('edgeRelNameInput').value.trim();
  const implName = document.getElementById("edgeImplInput").value;
  const implType = document.getElementById("edgeImplTypeInput").value;
  const relType = selectedEdge.data("rel_type");

  selectedEdge.data("label", label);
  selectedEdge.data("rel_name", relName);
  selectedEdge.data("impl_name", implName);
  selectedEdge.data("impl_type", implType);

  // âœ… åˆ¶åº¦çš„å±æ€§ã®å–å¾—
  const isRequired = document.getElementById("edgeRequiredCheckbox").checked;

  // âœ… edge_id å±æ€§ã«åæ˜ 
  const isProjectionEdge = implType.startsWith("*object<");
  if (isProjectionEdge) {
    selectedEdge.removeData("identifier");// edgeã§ã¯ã€identifierè‡ªä½“ç„¡ã„ãŒã€æ—¢å­˜ãƒ¢ãƒ‡ãƒ«ãƒ‡ãƒ¼ã‚¿ã§å«ã¾ã‚Œã¦ã„ã‚‹å±æ€§ã‚’å‰Šé™¤ã™ã‚‹ãŸã‚ã«å‰Šé™¤ã™ã‚‹ã€‚â˜…
    selectedEdge.removeData("required");
  } else {
    selectedEdge.data("required", isRequired);
  }

  // ã“ã“ã«è¿½åŠ  start
  // âœ… projection_fields ã®åé›†
  const projectionFields = [];
  const section = document.getElementById("projectionFieldsSection");
  if (section.style.display !== "none") {
    const items = section.querySelectorAll(".projectionFieldItem");

    items.forEach(item => {
      const checkbox = item.querySelector("input[type='checkbox']");
      const asInput = item.querySelector("input[type='text']");
      const requiredInput = item.querySelector("input[data-required]");

      if (checkbox?.checked) {
        const from = checkbox.getAttribute("data-from");
        const as = asInput?.value.trim();
        const required = requiredInput?.checked || false;

        const field = { from };
        if (as && as !== from) field.as = as;
        if (required) field.required = true;

        projectionFields.push(field);
      }
    });
  }

  // âœ… edge ã«ä¿å­˜
  selectedEdge.data("projection_fields", projectionFields);
  // ã“ã“ã«è¿½åŠ  end

  graphLabelUpdate();
  document.getElementById("edgeEditPanel").style.display = "none";
}

function convertIncludeToRef() {
  if (!selectedEdge) return;

  const base_type = selectedEdge.data("type");
  if (base_type !== "oneToOne-include" && base_type !== "oneToMany-include") return;

  const edgeData = selectedEdge.data();
  const cyInstance = selectedEdge.cy();

  // ä¿å­˜æƒ…å ±
  const originalSource = edgeData.source;
  const originalTarget = edgeData.target;

  const newEdgeData = {
    group: "edges",
    data: {
      id: generateUniqueId(), // æ–°ã—ã„IDï¼ˆã¾ãŸã¯ omit ã—ã¦ Cytoscapeã«ä»»ã›ã‚‹ï¼‰
      source: originalTarget, // â†å‘ãåè»¢
      target: originalSource,
      label: "ref",
      type: "oneToOne-ref",
      rel_type: "ref",        // ã‚¿ã‚¤ãƒ—è¨­å®šå±æ€§ã«è¨­å®š
      org_type: edgeData.type
    }
  };

  cyInstance.remove(selectedEdge); // å…ƒã‚¨ãƒƒã‚¸å‰Šé™¤
  const newEdge = cyInstance.add(newEdgeData);
  selectedEdge = newEdge;

  // ãƒ€ã‚¤ã‚¢ãƒ­ã‚°UIæ›´æ–°
  document.getElementById("edgeSourceName").textContent = newEdge.data("source");
  document.getElementById("edgeTargetName").textContent = newEdge.data("target");
  document.getElementById("edgeTypeName").textContent = newEdge.data("type");
  document.getElementById("edgeLabelInput").value = newEdge.data("label");
  document.getElementById("edgeImplInput").value = newEdge.data("impl_name") || "";
  document.getElementById("conversionNotice").textContent =
    `âœ… include ã‹ã‚‰ ref ã«å¤‰æ›ã•ã‚Œã¾ã—ãŸã€‚å…ƒç¨®åˆ¥: ${newEdge.data("org_type")}`;

}

function convertRefToInclude() {
  if (!selectedEdge) return;
  const org_type = selectedEdge.data("org_type");
  if (!org_type) return;
  if (selectedEdge.data("type") !== "oneToOne-ref") return;
  if (org_type !== "oneToOne-include" && org_type !== "oneToMany-include") return;
  
  const edgeData = selectedEdge.data();
  const cyInstance = selectedEdge.cy();

  const originalSource = edgeData.source;
  const originalTarget = edgeData.target;

  const newEdgeData = {
    group: "edges",
    data: {
      id: generateUniqueId(), // ã¾ãŸã¯ omit
      source: originalTarget, // â†å‘ãåè»¢ï¼ˆå…ƒã«æˆ»ã™ï¼‰
      target: originalSource,
      label: "include",
      type: "oneToMany-include",
      rel_type: "ref",        // ã‚¿ã‚¤ãƒ—è¨­å®šå±æ€§ã«è¨­å®š
      org_type: edgeData.type
    }
  };

  cyInstance.remove(selectedEdge);
  const newEdge = cyInstance.add(newEdgeData);
  selectedEdge = newEdge;

  // ãƒ€ã‚¤ã‚¢ãƒ­ã‚°UIæ›´æ–°
  document.getElementById("edgeSourceName").textContent = newEdge.data("source");
  document.getElementById("edgeTargetName").textContent = newEdge.data("target");
  document.getElementById("edgeTypeName").textContent = newEdge.data("type");
  document.getElementById("edgeLabelInput").value = newEdge.data("label");
  document.getElementById("edgeImplInput").value = newEdge.data("impl_name") || "";
  document.getElementById("conversionNotice").textContent =
    `âœ… ref ã‹ã‚‰ include ã«å¤‰æ›ã•ã‚Œã¾ã—ãŸã€‚å…ƒç¨®åˆ¥: ${newEdge.data("org_type")}`;
    
}

function closeEdgeEdit() {
  document.getElementById('edgeEditPanel').style.display = 'none';
}

//ãƒªãƒ­ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯
document.addEventListener('keydown', function (e) {
  // F5ã‚­ãƒ¼ï¼ˆkeyCode 116ï¼‰
  if (e.keyCode === 116) {
    e.preventDefault();
    console.log("ã“ã®ãƒšãƒ¼ã‚¸ã§ã¯ãƒªãƒ­ãƒ¼ãƒ‰ã§ãã¾ã›ã‚“ã€‚");
  }

  // Ctrl + Rï¼ˆkeyCode 82ï¼‰
  if (e.ctrlKey && e.keyCode === 82) {
    e.preventDefault();
    console.log("Ctrl+Rã«ã‚ˆã‚‹ãƒªãƒ­ãƒ¼ãƒ‰ã¯ç„¡åŠ¹ã§ã™ã€‚");
  }
});

// ãƒ‡ãƒ¼ã‚¿æ•´åˆæ€§ãƒã‚§ãƒƒã‚¯é–¢æ•°
function validateGraph(nodes, edges) {
  const errors = [];

  // --- ãƒãƒ¼ãƒ‰ã”ã¨ã®ãƒã‚§ãƒƒã‚¯ ---
  nodes.forEach(node => {
    const nodeId = node.data('id');
    const implName = node.data('impl_name');
    const fields = node.data('fields') || [];

    // impl_name ãŒå¿…é ˆ
    if (!implName) {
      errors.push(`Node ${nodeId} is missing impl_name.`);
    }

    // å±æ€§ã”ã¨ã®ãƒã‚§ãƒƒã‚¯
    fields.forEach((f, i) => {
      // name/type ãŒå¿…é ˆ
      if (!f.name) errors.push(`Field ${i} in node ${implName || nodeId} has no name.`);
      if (!f.type) errors.push(`Field ${f.name || i} in node ${implName || nodeId} has no type.`);

      // objectå‹ã®å ´åˆã¯æ§‹æ–‡æ¤œè¨¼
      if (f.type === "object") {
        if (f.value === undefined || f.value === null || f.value === "") {
          // ç©ºã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯è¨±å®¹ï¼ˆè­¦å‘Šï¼‰
          console.warn(`Field ${f.name} in node ${implName} has no value; assuming empty object.`);
        } else {
          try {
            const parsed = typeof f.value === "string" ? JSON.parse(f.value) : f.value;
            if (typeof parsed !== "object" || Array.isArray(parsed)) {
              errors.push(`Field ${f.name} in node ${implName} is not a valid object.`);
            }
          } catch (e) {
            errors.push(`Field ${f.name} in node ${implName} has invalid JSON structure.`);
          }
        }
      }
    });

    // subtypeã‚¨ãƒƒã‚¸ã®ãƒã‚§ãƒƒã‚¯ï¼ˆè¦ªãƒãƒ¼ãƒ‰ãŒå­˜åœ¨ã™ã‚‹ã‹ï¼‰
    const subtypeEdges = edges.filter(e =>
      e.data("rel_type") === "subtype" && e.data("source") === nodeId
    );
    subtypeEdges.forEach(e => {
      const parentId = e.data("target");
      const parentNode = nodes.find(n => n.data('id') === parentId);
      if (!parentNode) {
        errors.push(`Subtype edge from ${nodeId} points to missing parent ${parentId}.`);
      }
    });

    // â˜… å¤šé‡ç¶™æ‰¿ãƒã‚§ãƒƒã‚¯ â˜…
    if (subtypeEdges.length > 1) {
      const parentIds = subtypeEdges.map(e => e.data("target")).join(", ");
      errors.push(`Node ${implName || nodeId} has multiple subtype parents: ${parentIds}. Only one is allowed.`);
    }

  });

  // ãƒãƒ¼ãƒ‰å®Ÿè£…åã®ä¸€æ„æ€§ãƒã‚§ãƒƒã‚¯
  const implNames = nodes
    .map(n => n.data('impl_name'))
    .filter(Boolean); // impl_name ãŒå­˜åœ¨ã™ã‚‹ã‚‚ã®ã ã‘å¯¾è±¡

  // é‡è¤‡æ¤œå‡º
  const duplicates = implNames.filter((name, i, arr) => arr.indexOf(name) !== i);

  if (duplicates.length > 0) {
    // é‡è¤‡ã‚’ãƒ¦ãƒ‹ãƒ¼ã‚¯åŒ–ã—ã¦ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã«ã¾ã¨ã‚ã‚‹
    const dupList = [...new Set(duplicates)].join(', ');
    errors.push(`Duplicate impl_name(s) found: ${dupList}`);
  }

  // --- ã‚¨ãƒƒã‚¸ã”ã¨ã®ãƒã‚§ãƒƒã‚¯ ---
  edges.forEach(edge => {
    const source = edge.data("source");
    const target = edge.data("target");
    const implName = edge.data("impl_name");
    const implType = edge.data("impl_type");

    // source/target ãŒå¿…é ˆ
    if (!source || !target) {
      errors.push(`Edge missing source or target: ${JSON.stringify(edge.data())}`);
    }

    // subtypeä»¥å¤–ã®ã‚¨ãƒƒã‚¸ã«å¯¾ã™ã‚‹ãƒã‚§ãƒƒã‚¯
    if (edge.data("rel_type") !== "subtype") {
      const implType = edge.data("impl_type") || "";
      const isObjectStar = implType.startsWith("*object<");

      // impl_name ãŒå¿…é ˆï¼ˆãŸã ã— *object<...> ã®å ´åˆã¯ä¾‹å¤–ï¼‰
      if (!implName && !isObjectStar) {
        errors.push(`Edge from ${source} to ${target} missing impl_name.`);
      }

      // impl_type ãŒå¿…é ˆ
      if (!implType) {
        errors.push(`Edge ${implName || "(unnamed)"} missing impl_type.`);
      }
    }

    // *object<...> å‹ã®ã‚¨ãƒƒã‚¸ã«å¯¾ã™ã‚‹ãƒã‚§ãƒƒã‚¯
    if (implType && implType.startsWith("*object<")) {
      const match = implType.match(/^\*object<(.+)>$/);
      if (match) {
        const targetImpl = match[1];
        const targetNode = nodes.find(n => n.data("impl_name") === targetImpl);
        if (!targetNode) {
          errors.push(`Edge ${implName} refers to missing target impl_name: ${targetImpl}.`);
        } else {
          const projectionFields = edge.data("projection_fields") || [];
          const targetFields = targetNode.data("fields") || [];

          // projection_fields ã®å¦¥å½“æ€§ãƒã‚§ãƒƒã‚¯
          projectionFields.forEach((proj, i) => {
            if (!proj.from) {
              errors.push(`Projection field ${i} in edge ${implName} is missing 'from'.`);
            } else if (!targetFields.find(f => f.name === proj.from)) {
              errors.push(`Projection field '${proj.from}' in edge ${implName} not found in target ${targetImpl}.`);
            }
            if (proj.as) {
              const duplicates = projectionFields.filter(p => p.as === proj.as);
              if (duplicates.length > 1) {
                errors.push(`Duplicate 'as' name '${proj.as}' in edge ${implName}.`);
              }
            }
          });
        }
      }
    }
  });

  // --- ãƒãƒ¼ãƒ‰å±æ€§ã®ä¸€æ„æ€§ãƒã‚§ãƒƒã‚¯ ---
  nodes.forEach(node => {
    const implName = node.data('impl_name') || node.data('id');
    const fields = node.data('fields') || [];

    // discriminator ãŒè¤‡æ•°è¨­å®šã•ã‚Œã¦ã„ãªã„ã‹
    const discriminatorFields = fields.filter(f => f.discriminator === true);
    if (discriminatorFields.length > 1) {
      const names = discriminatorFields.map(f => f.name || '(unnamed)').join(', ');
      errors.push(`Node ${implName} has multiple discriminator fields: ${names}. Only one is allowed.`);
    }
  });

  nodes.forEach(node => {
    const implName = node.data('impl_name') || node.data('id');
    const fields = node.data('fields') || [];

    // identifier ãŒè¤‡æ•°è¨­å®šã•ã‚Œã¦ã„ãªã„ã‹
    const identifierFields = fields.filter(f => f.identifier === true);
    if (identifierFields.length > 1) {
      const names = identifierFields.map(f => f.name || '(unnamed)').join(', ');
      errors.push(`Node ${implName} has multiple identifier fields: ${names}. Only one is allowed.`);
    }
  });

  return errors;
}

// check JSON Graph
function checkGraph() {
  const nodes = cy_model.nodes().filter(n => n.group() === 'nodes');
  const edges = cy_model.edges();

  const errors = validateGraph(nodes, edges);

  if (errors.length > 0) {
    console.error(`Graph validation failed: ${errors.length} error(s)`);

    const displayErrors = errors.slice(0, 2);
    displayErrors.forEach((err, i) => {
      console.error(`Error ${i + 1}: ${err}`);
    });

    if (errors.length > 2) {
      console.error(`Error 3: ...`);
    }

    alert(`JSON Graphã« ${errors.length} ä»¶ã®ã‚¨ãƒ©ãƒ¼ãŒã‚ã‚Šã¾ã™ã€‚\n` +
      displayErrors.map((e, i) => `(${i + 1}) ${e}`).join("\n") +
      (errors.length > 2 ? `\n(3) ...` : "")
    );
  } else {
    showToast(`ãƒ¢ãƒ‡ãƒ«ã®æ•´åˆæ€§ãƒã‚§ãƒƒã‚¯ã§ã€å•é¡Œã¯è¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚`);
  }
  return;
}

function expandObjectField(nodes, edges, implName) {
  const targetNode = nodes.find(n => n.data("impl_name") === implName);
  if (!targetNode) return {};

  const obj = {};
  const fields = targetNode.data("fields") || [];
  fields.forEach(f => {
    if (f.type === "array") {
      obj[f.name] = [];
    } else if (f.type.startsWith("object<")) {
      const nestedImpl = f.type.match(/^object<(.+)>$/)[1];
      obj[f.name] = expandObjectField(nodes, edges, nestedImpl);
    } else {
      obj[f.name] = f.type;
    }
  });
  return obj;
}

function makeSimpleJson(nodes, edges, cur_node) {
  const path = [];
  let current = cur_node;

  while (current) {
    path.unshift(current);
    const parentEdge = edges.find(e =>
      e.data("rel_type") === "subtype" && e.data("source") === current.data("id")
    );
    current = parentEdge
      ? nodes.find(n => n.data("id") === parentEdge.data("target"))
      : null;
  }

  console.log(path);

  const json = {};
  let index = 0;
  path.forEach(node => {
    const fields = node.data("fields") || [];
    console.log(index);

    // å±æ€§å‡¦ç†
    fields.forEach(f => {
      if (f.discriminator){
        json[f.name] = f.type;
        if ((index + 1) < path.length){
          json[f.name] = path[index + 1].data("impl_name");
        }
      } else if (f.type === "array" || f.type.startsWith("array<")) {
        json[f.name] = []; // ç©ºé…åˆ—ã«ã™ã‚‹
      } else if (f.type.startsWith("object<")) {
        const implName = f.type.match(/^object<(.+)>$/)[1];
        json[f.name] = expandObjectField(nodes, edges, implName);
      } else {
        json[f.name] = f.type;
      }
    });

    // âœ… include ã‚¨ãƒƒã‚¸ã‹ã‚‰å±æ€§ã‚’è¿½åŠ 
    edges.filter(e =>
      e.data("source") === node.data("id") &&
      e.data("rel_type") === "include" &&
      e.data("impl_name") && e.data("impl_type")
    ).forEach(edge => {
      const implName = edge.data("impl_name");
      const implType = edge.data("impl_type");

      if (implType.startsWith("array<")) {
        json[implName] = [];
      } else if (implType.startsWith("object<")) {
        const targetImpl = implType.match(/^object<(.+)>$/)[1];
        json[implName] = expandObjectField(nodes, edges, targetImpl);
      } else if (implType === "object") {
        json[implName] = {}; // ç©ºã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§åˆæœŸåŒ–
      } else {
        json[implName] = implType;
      }

    });

    // ref ã‚¨ãƒƒã‚¸ã‹ã‚‰å±æ€§ã‚’è¿½åŠ 
    edges.filter(e =>
      e.data("source") === node.data("id") &&
      e.data("rel_type") === "ref" &&
      e.data("impl_type")
    ).forEach(edge => {
      const implName = edge.data("impl_name");
      const implType = edge.data("impl_type");

      if (implType.startsWith("*object<")) {
        // projection_fields ã«ã‚ˆã‚‹éƒ¨åˆ†å‚ç…§
        const projections = edge.data("projection_fields") || [];
        projections.forEach(p => {
          const key = p.as || p.from;
          const targetImpl = implType.match(/^\*object<(.+)>$/)[1];
          const targetNode = nodes.find(n => n.data("impl_name") === targetImpl);
          const targetField = targetNode?.data("fields")?.find(f => f.name === p.from);
          json[key] = targetField ? targetField.type : "unknown";
        });
      } else {
        // é€šå¸¸ã® ref ã¯ ID å‚ç…§ã¨ã—ã¦ string ã‚’å‡ºåŠ›
        if (implName) {
          json[implName] = "string";
        }
      }
    });

    // projection_fields
    edges.filter(e =>
      e.data("source") === node.data("id") &&
      e.data("impl_type") &&
      e.data("impl_type").startsWith("*object<")
    ).forEach(edge => {
      const projections = edge.data("projection_fields") || [];
      projections.forEach(p => {
        const key = p.as || p.from;
        const targetImpl = edge.data("impl_type").match(/^\*object<(.+)>$/)[1];
        const targetNode = nodes.find(n => n.data("impl_name") === targetImpl);
        const targetField = targetNode?.data("fields")?.find(f => f.name === p.from);
        json[key] = targetField ? targetField.type : "unknown";
      });
    });
    index += 1;
  });

  return json;
}

// JSON ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼æ©Ÿèƒ½å‘¼ã³å‡ºã—
let currentPreviewObject = null;
let currentPreviewJsonString = "";
let previewMode = 'json';

function previewJson() {
  
  const nodes = cy_model.nodes().filter(n => n.group() === 'nodes');
  const edges = cy_model.edges();
  if (!selectedNode) {
    alert("ãƒãƒ¼ãƒ‰ã‚’é¸æŠã—ã¦ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã¦ãã ã•ã„ã€‚");
    return;
  }

  const errors = validateGraph(nodes, edges);
  if (errors.length > 0) {
    console.error("Validation errors:", errors);
    alert("ãƒ¢ãƒ‡ãƒ«ã«å•é¡ŒãŒã‚ã‚Šã¾ã™ã€‚ãƒã‚§ãƒƒã‚¯çµæœã‚’è¡¨ç¤ºã—ã¾ã™ã€‚");
    checkGraph();
    return;
  }

  closeAllDialogs();

  setPreviewMode('json');

  const json = makeSimpleJson(nodes, edges, selectedNode);
  currentPreviewObject = json;
  const jsonString = JSON.stringify(json, null, 2);
  currentPreviewJsonString = jsonString; 
  console.log(jsonString);
  const title = `[${selectedNode.data("id")}]`;
  openPreviewDialog(title, jsonString);
}

//ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ãƒ€ã‚¤ã‚¢ãƒ­ã‚°é–¢ä¿‚
function showToast(message) {
  const toast = document.getElementById("toast");
  toast.textContent = message;
  toast.classList.add("show");

  setTimeout(() => {
    toast.classList.remove("show");
  }, 1500);
}

function openPreviewDialog(title,jsonString) {
  const dialog = document.getElementById("previewDialog");
  const content = document.getElementById("previewContent");

  if (!dialog || !content) {
    console.error("Preview dialog elements not found.");
    return;
  }
  document.getElementById("previewNodeName").textContent = title;
  content.textContent = jsonString;
  dialog.style.display = "block"; // ãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã‚’è¡¨ç¤º
  // åˆæœŸã‚¿ãƒ–çŠ¶æ…‹
  const tabJson = document.querySelector("#previewTabs button:nth-child(1)");
  const tabJs = document.querySelector("#previewTabs button:nth-child(2)");

  if (tabJson && tabJs) {
    tabJson.classList.add("active");
    tabJs.classList.remove("active");
  }

}

function closePreviewDialog() {
  const dialog = document.getElementById("previewDialog");
  if (dialog) {
    dialog.style.display = "none"; // ãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã‚’éè¡¨ç¤º
  }
}

function copyPreviewJson() {
  const text = document.getElementById("previewContent").textContent;
  navigator.clipboard.writeText(text);
  showToast("ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸ");

}

function toJsObjectLiteral(jsonString) {
  return jsonString.replace(/"([^"]+)":/g, '$1:');
}

function toJsObjectLiteralShorthand(jsonString) {
  const obj = JSON.parse(jsonString);

  function convert(value, indentLevel = 0) {
    const indent = "  ".repeat(indentLevel);
    const childIndent = "  ".repeat(indentLevel + 1);

    // â˜… é…åˆ—ã¯çœç•¥è¨˜æ³•æ‰±ã„ã«ã™ã‚‹
    if (Array.isArray(value)) {
      return null; // å€¤ã¯ä½¿ã‚ãªã„
    }

    if (value !== null && typeof value === "object") {
      const entries = Object.entries(value).map(([key, val]) => {

        // â˜… ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–å€¤ã‚‚é…åˆ—ã‚‚çœç•¥è¨˜æ³•ã«ã™ã‚‹
        if (typeof val !== "object" || Array.isArray(val)) {
          return `${childIndent}${key}`;
        }

        // ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯å†å¸°å‡¦ç†
        const converted = convert(val, indentLevel + 1);
        return `${childIndent}${key}: ${converted}`;
      });

      return `{\n${entries.join(",\n")}\n${indent}}`;
    }

    return String(value);
  }

  return convert(obj, 0);
}

function toJsVariablesLiteral(jsonString) {
  const obj = JSON.parse(jsonString);
  let lines = [];

  for (const key in obj) {
    const value = obj[key];

    // å€¤ã®ç¨®é¡ã«å¿œã˜ã¦æ–‡å­—åˆ—åŒ–
    let v;
    if (Array.isArray(value)) {
      v = '[]';
    } else if (typeof value === 'object' && value !== null) {
      v = '{}';
    } else {
      v = JSON.stringify(value);
    }

    lines.push(`let ${key} = ${v};`);
  }

  return lines.join('\n');
}

function updatePreviewContent() {
  if (previewMode === 'json') {
    previewContent.textContent = currentPreviewJsonString;
  } else if (previewMode === 'js-shorthand') {
    previewContent.textContent = toJsObjectLiteralShorthand(currentPreviewJsonString);
  } else if (previewMode === 'js-vars') {   // â˜… è¿½åŠ 
    previewContent.textContent = toJsVariablesLiteral(currentPreviewJsonString); // â˜… è¿½åŠ 
  } else {
    previewContent.textContent = toJsObjectLiteral(currentPreviewJsonString);
  }
}

function setPreviewMode(mode) {
  previewMode = mode;
  
  const tabJson = document.getElementById("tabJson");
  const tabJs = document.getElementById("tabJs");
  const tabJsShorthand = document.getElementById("tabJsShorthand");
  const tabJsVars = document.getElementById("tabJsVars"); // â˜…è¿½åŠ 

  tabJson.classList.toggle("active", mode === "json");
  tabJs.classList.toggle("active", mode === "js");
  tabJsShorthand.classList.toggle("active", mode === "js-shorthand");
  tabJsVars.classList.toggle("active", mode === "js-vars"); // â˜…è¿½åŠ 

  updatePreviewContent();
}

</script>

</body>
</html>